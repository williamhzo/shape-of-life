{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-9bee795e65c4059bb70198422a8254cafcb592b2",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "src/ConwayArenaRound.sol": "project/src/ConwayArenaRound.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/src/ConwayArenaRound.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {ConwayEngine} from \"./ConwayEngine.sol\";\n\ncontract ConwayArenaRound {\n    enum Phase {\n        Commit,\n        Reveal,\n        Sim,\n        Claim\n    }\n\n    error InvalidPhase(Phase expected, Phase actual);\n    error InvalidConfiguration();\n    error CommitWindowOpen();\n    error CommitWindowClosed();\n    error RevealWindowOpen();\n    error RevealWindowClosed();\n    error InvalidTeam(uint8 team);\n    error InvalidSlotIndex(uint8 slotIndex);\n    error SlotOutOfTerritory(uint8 team, uint8 slotIndex);\n    error SlotAlreadyReserved(uint8 slotIndex);\n    error SlotNotReserved(uint8 slotIndex);\n    error SlotNotRevealed(uint8 slotIndex);\n    error AddressAlreadyCommitted(address player);\n    error NotSlotOwner(address expected, address caller);\n    error AlreadyRevealed(uint8 slotIndex);\n    error AlreadyClaimed(uint8 slotIndex);\n    error CommitHashMismatch();\n    error SeedBudgetExceeded(uint8 liveCells, uint8 seedBudget);\n    error NoKeeperCredit(address keeper);\n    error TransferFailed();\n    error ManualSettlementDisabled();\n    error ZeroSteps();\n    error RoundNotTerminal();\n    error AccountingAlreadyConfigured();\n    error ClaimsAlreadySettled();\n    error ReentrancyBlocked();\n    error InsufficientRoundBalance(uint256 required, uint256 available);\n\n    uint16 public constant WINNER_BPS = 8000;\n    uint16 public constant KEEPER_BPS = 2000;\n    uint16 public constant BPS_DENOMINATOR = 10000;\n    uint8 public constant TEAM_BLUE = 0;\n    uint8 public constant TEAM_RED = 1;\n    uint8 public constant WINNER_DRAW = 2;\n    uint8 public constant SLOT_COUNT = 64;\n    uint8 public constant TEAM_SLOT_COUNT = 32;\n    uint8 public constant SLOT_EDGE = 8;\n    uint8 public constant SLOT_COLUMNS = 8;\n    uint8 public constant BOARD_WIDTH = 64;\n    uint8 public constant BOARD_HEIGHT = 64;\n    uint8 public constant SEED_BUDGET = 12;\n    uint8 public constant SCORE_WEIGHT_POP = 3;\n    uint8 public constant SCORE_WEIGHT_INVADE = 2;\n    uint8 private constant PACKED_WORD_COUNT = 16;\n    uint64 private constant RIGHT_HALF_MASK = type(uint64).max << 32;\n    uint64 private constant LEFT_HALF_MASK = uint64(type(uint32).max);\n\n    event Committed(address player, uint8 team, uint8 slotIndex);\n    event Revealed(address player, uint8 team, uint8 slotIndex);\n    event Initialized();\n    event Stepped(uint16 fromGen, uint16 toGen, address keeper, uint256 reward);\n    event Finalized(uint16 finalGen, uint256 winnerPoolFinal, uint256 keeperPaid, uint256 treasuryDust, uint8 winnerTeam, uint32 scoreBlue, uint32 scoreRed);\n    event Claimed(uint256 distributed, uint256 cumulativeWinnerPaid, uint256 treasuryDust, uint256 remainingWinnerPool);\n    event PlayerClaimed(address player, uint8 slotIndex, uint256 amount);\n    event KeeperCreditWithdrawn(address keeper, uint256 amount);\n\n    struct SlotData {\n        address player;\n        uint8 team;\n        bytes32 commitHash;\n        uint64 seedBits;\n        bool revealed;\n        bool claimed;\n    }\n\n    Phase public phase;\n    uint64 public commitEnd;\n    uint64 public revealEnd;\n    uint64 public immutable revealDuration;\n    uint16 public gen;\n    uint16 public immutable maxGen;\n    uint16 public immutable maxBatch;\n    bool public blueExtinct;\n    bool public redExtinct;\n    bool public accountingConfigured;\n    bool public winnerClaimsSettled;\n    bool public payoutLocked;\n    bool private reentrancyLock;\n    uint8 public winnerTeam;\n    uint8 public revealedBlueCount;\n    uint8 public revealedRedCount;\n    uint16 public finalBluePopulation;\n    uint16 public finalRedPopulation;\n    uint16 public finalBlueInvasion;\n    uint16 public finalRedInvasion;\n    uint32 public scoreBlue;\n    uint32 public scoreRed;\n    uint256 public totalFunded;\n    uint256 public rewardPerGen;\n    uint256 public payoutPerClaim;\n    uint256 public winnerPool;\n    uint256 public keeperPoolRemaining;\n    uint256 public keeperPaid;\n    uint256 public winnerPaid;\n    uint256 public treasuryDust;\n    uint256[PACKED_WORD_COUNT] public bluePacked;\n    uint256[PACKED_WORD_COUNT] public redPacked;\n    mapping(address keeper => uint256 credit) public keeperCredits;\n    mapping(uint8 slotIndex => SlotData slot) public slots;\n    mapping(address player => bool reserved) public hasReservedSlot;\n\n    receive() external payable {}\n\n    constructor(uint64 commitDuration, uint64 revealDuration_, uint16 maxGen_, uint16 maxBatch_) {\n        if (maxGen_ == 0 || maxBatch_ == 0 || maxBatch_ > maxGen_) {\n            revert InvalidConfiguration();\n        }\n\n        phase = Phase.Commit;\n        commitEnd = uint64(block.timestamp) + commitDuration;\n        revealDuration = revealDuration_;\n        maxGen = maxGen_;\n        maxBatch = maxBatch_;\n    }\n\n    function commit() external view {\n        requireCommitOpen();\n    }\n\n    function commit(uint8 team, uint8 slotIndex, bytes32 commitHash) external {\n        requireCommitOpen();\n        validateTeam(team);\n        validateSlotForTeam(team, slotIndex);\n\n        SlotData storage slot = slots[slotIndex];\n        if (slot.player != address(0)) {\n            revert SlotAlreadyReserved(slotIndex);\n        }\n        if (hasReservedSlot[msg.sender]) {\n            revert AddressAlreadyCommitted(msg.sender);\n        }\n\n        slot.player = msg.sender;\n        slot.team = team;\n        slot.commitHash = commitHash;\n        hasReservedSlot[msg.sender] = true;\n\n        emit Committed(msg.sender, team, slotIndex);\n    }\n\n    function beginReveal() external {\n        requirePhase(Phase.Commit);\n        if (block.timestamp <= commitEnd) {\n            revert CommitWindowOpen();\n        }\n\n        phase = Phase.Reveal;\n        revealEnd = uint64(block.timestamp) + revealDuration;\n    }\n\n    function reveal() external view {\n        requireRevealOpen();\n    }\n\n    function reveal(uint256 roundId, uint8 team, uint8 slotIndex, uint64 seedBits, bytes32 salt) external {\n        requireRevealOpen();\n        validateTeam(team);\n        validateSlotForTeam(team, slotIndex);\n\n        SlotData storage slot = slots[slotIndex];\n        if (slot.player == address(0)) {\n            revert SlotNotReserved(slotIndex);\n        }\n        if (slot.player != msg.sender) {\n            revert NotSlotOwner(slot.player, msg.sender);\n        }\n        if (slot.revealed) {\n            revert AlreadyRevealed(slotIndex);\n        }\n\n        uint8 liveCells = popcount(seedBits);\n        if (liveCells > SEED_BUDGET) {\n            revert SeedBudgetExceeded(liveCells, SEED_BUDGET);\n        }\n\n        bytes32 expectedCommit = computeCommitHash(roundId, msg.sender, team, slotIndex, seedBits, salt);\n        if (slot.commitHash != expectedCommit) {\n            revert CommitHashMismatch();\n        }\n\n        slot.seedBits = seedBits;\n        slot.revealed = true;\n        if (team == TEAM_BLUE) {\n            unchecked {\n                revealedBlueCount += 1;\n            }\n        } else {\n            unchecked {\n                revealedRedCount += 1;\n            }\n        }\n\n        emit Revealed(msg.sender, team, slotIndex);\n    }\n\n    function initialize() external {\n        requirePhase(Phase.Reveal);\n        if (block.timestamp <= revealEnd) {\n            revert RevealWindowOpen();\n        }\n\n        if (accountingConfigured) {\n            uint256 baseWinnerPool = (totalFunded * WINNER_BPS) / BPS_DENOMINATOR;\n            uint256 baseKeeperPool = (totalFunded * KEEPER_BPS) / BPS_DENOMINATOR;\n\n            winnerPool = baseWinnerPool;\n            keeperPoolRemaining = baseKeeperPool;\n            treasuryDust += totalFunded - baseWinnerPool - baseKeeperPool;\n        }\n\n        materializeBoardFromRevealedSeeds();\n        refreshBoardStatus();\n        phase = Phase.Sim;\n\n        emit Initialized();\n    }\n\n    function stepBatch(uint16 requestedSteps) external {\n        requirePhase(Phase.Sim);\n        if (requestedSteps == 0) {\n            revert ZeroSteps();\n        }\n\n        uint16 fromGen = gen;\n        uint16 remaining = maxGen - gen;\n        uint16 actualSteps = requestedSteps;\n        if (actualSteps > maxBatch) {\n            actualSteps = maxBatch;\n        }\n        if (actualSteps > remaining) {\n            actualSteps = remaining;\n        }\n\n        if (actualSteps > 0) {\n            (uint64[] memory nextBlueRows, uint64[] memory nextRedRows) = loadBoardRows();\n            for (uint16 stepIndex = 0; stepIndex < actualSteps;) {\n                (nextBlueRows, nextRedRows) = ConwayEngine.step(BOARD_WIDTH, BOARD_HEIGHT, nextBlueRows, nextRedRows);\n                unchecked {\n                    stepIndex += 1;\n                }\n            }\n            storeBoardRows(nextBlueRows, nextRedRows);\n            refreshBoardStatus();\n        }\n\n        gen += actualSteps;\n\n        uint256 keeperReward;\n        if (rewardPerGen > 0 && actualSteps > 0) {\n            keeperReward = uint256(actualSteps) * rewardPerGen;\n            if (keeperReward > keeperPoolRemaining) {\n                keeperReward = keeperPoolRemaining;\n            }\n\n            if (keeperReward > 0) {\n                keeperPoolRemaining -= keeperReward;\n                keeperPaid += keeperReward;\n                keeperCredits[msg.sender] += keeperReward;\n            }\n        }\n\n        emit Stepped(fromGen, gen, msg.sender, keeperReward);\n    }\n\n    function finalize() external {\n        requirePhase(Phase.Sim);\n        refreshBoardStatus();\n        if (gen != maxGen && !(blueExtinct || redExtinct)) {\n            revert RoundNotTerminal();\n        }\n\n        winnerPool += keeperPoolRemaining;\n        keeperPoolRemaining = 0;\n        winnerTeam = resolveWinnerTeam();\n\n        if (accountingConfigured && eligibleClaimCount() == 0) {\n            payoutLocked = true;\n            payoutPerClaim = 0;\n            treasuryDust += winnerPool;\n            winnerPool = 0;\n        }\n\n        phase = Phase.Claim;\n\n        emit Finalized(gen, winnerPool, keeperPaid, treasuryDust, winnerTeam, scoreBlue, scoreRed);\n    }\n\n    function claim() external view {\n        requirePhase(Phase.Claim);\n    }\n\n    function claim(uint8 slotIndex) external nonReentrant returns (uint256 amount) {\n        requirePhase(Phase.Claim);\n\n        if (slotIndex >= SLOT_COUNT) {\n            revert InvalidSlotIndex(slotIndex);\n        }\n\n        SlotData storage slot = slots[slotIndex];\n        if (slot.player == address(0)) {\n            revert SlotNotReserved(slotIndex);\n        }\n        if (!slot.revealed) {\n            revert SlotNotRevealed(slotIndex);\n        }\n        if (slot.player != msg.sender) {\n            revert NotSlotOwner(slot.player, msg.sender);\n        }\n        if (slot.claimed) {\n            revert AlreadyClaimed(slotIndex);\n        }\n\n        slot.claimed = true;\n\n        if (accountingConfigured && !winnerClaimsSettled) {\n            lockPayoutIfNeeded();\n            if (payoutPerClaim > 0 && isPayoutEligible(slot.team)) {\n                amount = payoutPerClaim;\n                winnerPool -= amount;\n                winnerPaid += amount;\n\n                (bool success,) = payable(msg.sender).call{value: amount}(\"\");\n                if (!success) {\n                    revert TransferFailed();\n                }\n            }\n        }\n\n        emit PlayerClaimed(msg.sender, slotIndex, amount);\n    }\n\n    function previewClaim(uint8 slotIndex) external view returns (uint256 amount) {\n        if (phase != Phase.Claim) {\n            return 0;\n        }\n        if (slotIndex >= SLOT_COUNT) {\n            return 0;\n        }\n\n        SlotData storage slot = slots[slotIndex];\n        if (slot.player == address(0) || !slot.revealed || slot.claimed) {\n            return 0;\n        }\n        if (!accountingConfigured || winnerClaimsSettled) {\n            return 0;\n        }\n\n        if (payoutLocked) {\n            if (payoutPerClaim > 0 && isPayoutEligible(slot.team)) {\n                return payoutPerClaim;\n            }\n            return 0;\n        }\n\n        uint256 eligibleClaims = eligibleClaimCount();\n        if (eligibleClaims == 0) {\n            return 0;\n        }\n        if (!isPayoutEligible(slot.team)) {\n            return 0;\n        }\n        return winnerPool / eligibleClaims;\n    }\n\n    function configureAccounting(uint256 totalFunded_, uint256 rewardPerGen_) external {\n        requirePhase(Phase.Commit);\n        if (accountingConfigured) {\n            revert AccountingAlreadyConfigured();\n        }\n        if (address(this).balance < totalFunded_) {\n            revert InsufficientRoundBalance(totalFunded_, address(this).balance);\n        }\n\n        accountingConfigured = true;\n        totalFunded = totalFunded_;\n        rewardPerGen = rewardPerGen_;\n    }\n\n    function withdrawKeeperCredit() external nonReentrant returns (uint256 amount) {\n        amount = keeperCredits[msg.sender];\n        if (amount == 0) {\n            revert NoKeeperCredit(msg.sender);\n        }\n\n        keeperCredits[msg.sender] = 0;\n\n        (bool success,) = payable(msg.sender).call{value: amount}(\"\");\n        if (!success) {\n            revert TransferFailed();\n        }\n\n        emit KeeperCreditWithdrawn(msg.sender, amount);\n    }\n\n    function hashCommit(\n        uint256 roundId,\n        address player,\n        uint8 team,\n        uint8 slotIndex,\n        uint64 seedBits,\n        bytes32 salt\n    ) external view returns (bytes32) {\n        return computeCommitHash(roundId, player, team, slotIndex, seedBits, salt);\n    }\n\n    function settleWinnerClaims(uint256 eligibleWinners) external {\n        requirePhase(Phase.Claim);\n        if (accountingConfigured) {\n            revert ManualSettlementDisabled();\n        }\n        if (winnerClaimsSettled) {\n            revert ClaimsAlreadySettled();\n        }\n\n        winnerClaimsSettled = true;\n        uint256 distributed;\n\n        if (eligibleWinners == 0) {\n            treasuryDust += winnerPool;\n            winnerPool = 0;\n            emit Claimed(distributed, winnerPaid, treasuryDust, winnerPool);\n            return;\n        }\n\n        uint256 payoutPerWinner = winnerPool / eligibleWinners;\n        distributed = payoutPerWinner * eligibleWinners;\n        winnerPaid += distributed;\n        treasuryDust += winnerPool - distributed;\n        winnerPool = 0;\n\n        emit Claimed(distributed, winnerPaid, treasuryDust, winnerPool);\n    }\n\n    function getBoardState()\n        external\n        view\n        returns (uint64[BOARD_HEIGHT] memory blue, uint64[BOARD_HEIGHT] memory red)\n    {\n        for (uint8 i = 0; i < PACKED_WORD_COUNT;) {\n            uint256 blueWord = bluePacked[i];\n            uint256 redWord = redPacked[i];\n            uint8 baseRow = i * 4;\n\n            blue[baseRow]     = uint64(blueWord);\n            blue[baseRow + 1] = uint64(blueWord >> 64);\n            blue[baseRow + 2] = uint64(blueWord >> 128);\n            blue[baseRow + 3] = uint64(blueWord >> 192);\n\n            red[baseRow]     = uint64(redWord);\n            red[baseRow + 1] = uint64(redWord >> 64);\n            red[baseRow + 2] = uint64(redWord >> 128);\n            red[baseRow + 3] = uint64(redWord >> 192);\n\n            unchecked { i += 1; }\n        }\n    }\n\n    function requirePhase(Phase expected) internal view {\n        if (phase != expected) {\n            revert InvalidPhase(expected, phase);\n        }\n    }\n\n    function requireCommitOpen() internal view {\n        requirePhase(Phase.Commit);\n        if (block.timestamp > commitEnd) {\n            revert CommitWindowClosed();\n        }\n    }\n\n    function requireRevealOpen() internal view {\n        requirePhase(Phase.Reveal);\n        if (block.timestamp > revealEnd) {\n            revert RevealWindowClosed();\n        }\n    }\n\n    function validateTeam(uint8 team) internal pure {\n        if (team != TEAM_BLUE && team != TEAM_RED) {\n            revert InvalidTeam(team);\n        }\n    }\n\n    function validateSlotForTeam(uint8 team, uint8 slotIndex) internal pure {\n        if (slotIndex >= SLOT_COUNT) {\n            revert InvalidSlotIndex(slotIndex);\n        }\n\n        uint8 tileX = slotIndex % SLOT_COLUMNS;\n        if (team == TEAM_BLUE && tileX >= SLOT_COLUMNS / 2) {\n            revert SlotOutOfTerritory(team, slotIndex);\n        }\n        if (team == TEAM_RED && tileX < SLOT_COLUMNS / 2) {\n            revert SlotOutOfTerritory(team, slotIndex);\n        }\n    }\n\n    function computeCommitHash(\n        uint256 roundId,\n        address player,\n        uint8 team,\n        uint8 slotIndex,\n        uint64 seedBits,\n        bytes32 salt\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encode(roundId, block.chainid, address(this), player, team, slotIndex, seedBits, salt));\n    }\n\n    function popcount(uint64 value) internal pure returns (uint8 count) {\n        uint64 bits = value;\n        while (bits != 0) {\n            bits &= bits - 1;\n            unchecked {\n                count += 1;\n            }\n        }\n    }\n\n    function materializeBoardFromRevealedSeeds() internal {\n        clearBoardPacked();\n\n        uint64[] memory blueMemory = new uint64[](BOARD_HEIGHT);\n        uint64[] memory redMemory = new uint64[](BOARD_HEIGHT);\n\n        for (uint8 slotIndex = 0; slotIndex < SLOT_COUNT;) {\n            SlotData storage slot = slots[slotIndex];\n            if (slot.revealed && slot.seedBits != 0) {\n                placeSeedInMemory(slot.team, slotIndex, slot.seedBits, blueMemory, redMemory);\n            }\n\n            unchecked {\n                slotIndex += 1;\n            }\n        }\n\n        storeBoardRows(blueMemory, redMemory);\n    }\n\n    function clearBoardPacked() internal {\n        for (uint8 i = 0; i < PACKED_WORD_COUNT;) {\n            bluePacked[i] = 0;\n            redPacked[i] = 0;\n\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    function placeSeedInMemory(\n        uint8 team,\n        uint8 slotIndex,\n        uint64 seedBits,\n        uint64[] memory blueMemory,\n        uint64[] memory redMemory\n    ) internal pure {\n        uint8 baseX = (slotIndex % SLOT_COLUMNS) * SLOT_EDGE;\n        uint8 baseY = (slotIndex / SLOT_COLUMNS) * SLOT_EDGE;\n\n        for (uint8 localY = 0; localY < SLOT_EDGE;) {\n            uint8 bitShift = localY * SLOT_EDGE;\n            uint64 rowBits = uint64((seedBits >> bitShift) & uint64(0xFF));\n\n            if (rowBits != 0) {\n                uint8 boardY = baseY + localY;\n                uint64 shiftedRowBits = rowBits << baseX;\n                if (team == TEAM_BLUE) {\n                    blueMemory[boardY] |= shiftedRowBits;\n                } else {\n                    redMemory[boardY] |= shiftedRowBits;\n                }\n            }\n\n            unchecked {\n                localY += 1;\n            }\n        }\n    }\n\n    function loadBoardRows() internal view returns (uint64[] memory blueRowsMemory, uint64[] memory redRowsMemory) {\n        blueRowsMemory = new uint64[](BOARD_HEIGHT);\n        redRowsMemory = new uint64[](BOARD_HEIGHT);\n\n        for (uint8 i = 0; i < PACKED_WORD_COUNT;) {\n            uint256 blueWord = bluePacked[i];\n            uint256 redWord = redPacked[i];\n            uint8 baseRow = i * 4;\n\n            blueRowsMemory[baseRow]     = uint64(blueWord);\n            blueRowsMemory[baseRow + 1] = uint64(blueWord >> 64);\n            blueRowsMemory[baseRow + 2] = uint64(blueWord >> 128);\n            blueRowsMemory[baseRow + 3] = uint64(blueWord >> 192);\n\n            redRowsMemory[baseRow]     = uint64(redWord);\n            redRowsMemory[baseRow + 1] = uint64(redWord >> 64);\n            redRowsMemory[baseRow + 2] = uint64(redWord >> 128);\n            redRowsMemory[baseRow + 3] = uint64(redWord >> 192);\n\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    function storeBoardRows(uint64[] memory blueRowsMemory, uint64[] memory redRowsMemory) internal {\n        for (uint8 i = 0; i < PACKED_WORD_COUNT;) {\n            uint8 baseRow = i * 4;\n\n            bluePacked[i] = uint256(blueRowsMemory[baseRow])\n                | (uint256(blueRowsMemory[baseRow + 1]) << 64)\n                | (uint256(blueRowsMemory[baseRow + 2]) << 128)\n                | (uint256(blueRowsMemory[baseRow + 3]) << 192);\n\n            redPacked[i] = uint256(redRowsMemory[baseRow])\n                | (uint256(redRowsMemory[baseRow + 1]) << 64)\n                | (uint256(redRowsMemory[baseRow + 2]) << 128)\n                | (uint256(redRowsMemory[baseRow + 3]) << 192);\n\n            unchecked {\n                i += 1;\n            }\n        }\n    }\n\n    function refreshBoardStatus() internal {\n        uint16 bluePop;\n        uint16 redPop;\n        uint16 blueInvade;\n        uint16 redInvade;\n\n        for (uint8 i = 0; i < PACKED_WORD_COUNT;) {\n            uint256 blueWord = bluePacked[i];\n            uint256 redWord = redPacked[i];\n\n            for (uint8 j = 0; j < 4;) {\n                uint64 blueRow = uint64(blueWord >> (j * 64));\n                uint64 redRow = uint64(redWord >> (j * 64));\n                bluePop += uint16(popcount(blueRow));\n                redPop += uint16(popcount(redRow));\n                blueInvade += uint16(popcount(blueRow & RIGHT_HALF_MASK));\n                redInvade += uint16(popcount(redRow & LEFT_HALF_MASK));\n\n                unchecked { j += 1; }\n            }\n\n            unchecked {\n                i += 1;\n            }\n        }\n\n        finalBluePopulation = bluePop;\n        finalRedPopulation = redPop;\n        finalBlueInvasion = blueInvade;\n        finalRedInvasion = redInvade;\n        scoreBlue = uint32(bluePop) * SCORE_WEIGHT_POP + uint32(blueInvade) * SCORE_WEIGHT_INVADE;\n        scoreRed = uint32(redPop) * SCORE_WEIGHT_POP + uint32(redInvade) * SCORE_WEIGHT_INVADE;\n        blueExtinct = bluePop == 0;\n        redExtinct = redPop == 0;\n    }\n\n    function resolveWinnerTeam() internal view returns (uint8) {\n        if (blueExtinct && !redExtinct) {\n            return TEAM_RED;\n        }\n        if (redExtinct && !blueExtinct) {\n            return TEAM_BLUE;\n        }\n        if (scoreBlue > scoreRed) {\n            return TEAM_BLUE;\n        }\n        if (scoreRed > scoreBlue) {\n            return TEAM_RED;\n        }\n        return WINNER_DRAW;\n    }\n\n    function lockPayoutIfNeeded() internal {\n        if (payoutLocked) {\n            return;\n        }\n\n        payoutLocked = true;\n        uint256 eligibleClaims = eligibleClaimCount();\n        if (eligibleClaims == 0) {\n            treasuryDust += winnerPool;\n            winnerPool = 0;\n            payoutPerClaim = 0;\n            return;\n        }\n\n        payoutPerClaim = winnerPool / eligibleClaims;\n        uint256 distributablePool = payoutPerClaim * eligibleClaims;\n        treasuryDust += winnerPool - distributablePool;\n        winnerPool = distributablePool;\n    }\n\n    function eligibleClaimCount() internal view returns (uint256) {\n        if (winnerTeam == TEAM_BLUE) {\n            return revealedBlueCount;\n        }\n        if (winnerTeam == TEAM_RED) {\n            return revealedRedCount;\n        }\n        return uint256(revealedBlueCount) + uint256(revealedRedCount);\n    }\n\n    function isPayoutEligible(uint8 slotTeam) internal view returns (bool) {\n        if (winnerTeam == WINNER_DRAW) {\n            return true;\n        }\n        return slotTeam == winnerTeam;\n    }\n\n    modifier nonReentrant() {\n        if (reentrancyLock) {\n            revert ReentrancyBlocked();\n        }\n\n        reentrancyLock = true;\n        _;\n        reentrancyLock = false;\n    }\n}\n"
      },
      "project/src/ConwayEngine.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nlibrary ConwayEngine {\n    error InvalidDimensions();\n    error InvalidRowsLength();\n    error OverlappingCells();\n\n    function step(\n        uint8 width,\n        uint8 height,\n        uint64[] memory blueRows,\n        uint64[] memory redRows\n    ) internal pure returns (uint64[] memory nextBlueRows, uint64[] memory nextRedRows) {\n        if (width == 0 || width > 64 || height == 0) revert InvalidDimensions();\n        if (blueRows.length != height || redRows.length != height) revert InvalidRowsLength();\n\n        nextBlueRows = new uint64[](height);\n        nextRedRows = new uint64[](height);\n\n        uint64 widthMask = width == 64 ? type(uint64).max : uint64((uint256(1) << width) - 1);\n\n        for (uint8 y = 0; y < height; y++) {\n            if ((blueRows[y] & redRows[y]) != 0) revert OverlappingCells();\n\n            for (uint8 x = 0; x < width; x++) {\n                (uint8 blueNeighbors, uint8 redNeighbors) = countNeighbors(width, height, blueRows, redRows, x, y);\n\n                uint8 liveNeighbors = blueNeighbors + redNeighbors;\n                uint64 cellBit = uint64(1) << x;\n                bool aliveBlue = (blueRows[y] & cellBit) != 0;\n                bool aliveRed = (redRows[y] & cellBit) != 0;\n\n                if (aliveBlue || aliveRed) {\n                    if (liveNeighbors == 2 || liveNeighbors == 3) {\n                        if (aliveBlue) {\n                            nextBlueRows[y] |= cellBit;\n                        } else {\n                            nextRedRows[y] |= cellBit;\n                        }\n                    }\n                    continue;\n                }\n\n                if (liveNeighbors == 3) {\n                    if (blueNeighbors > redNeighbors) {\n                        nextBlueRows[y] |= cellBit;\n                    } else if (redNeighbors > blueNeighbors) {\n                        nextRedRows[y] |= cellBit;\n                    }\n                }\n            }\n\n            nextBlueRows[y] &= widthMask;\n            nextRedRows[y] &= widthMask;\n            if ((nextBlueRows[y] & nextRedRows[y]) != 0) revert OverlappingCells();\n        }\n    }\n\n    function countNeighbors(\n        uint8 width,\n        uint8 height,\n        uint64[] memory blueRows,\n        uint64[] memory redRows,\n        uint8 x,\n        uint8 y\n    ) private pure returns (uint8 blueNeighbors, uint8 redNeighbors) {\n        for (int8 dy = -1; dy <= 1; dy++) {\n            for (int8 dx = -1; dx <= 1; dx++) {\n                if (dx == 0 && dy == 0) continue;\n\n                int16 nxI = int16(uint16(x)) + dx;\n                if (nxI < 0 || nxI >= int16(uint16(width))) continue;\n\n                uint8 ny = wrapY(y, dy, height);\n                uint64 bit = uint64(1) << uint16(nxI);\n\n                if ((blueRows[ny] & bit) != 0) {\n                    blueNeighbors++;\n                } else if ((redRows[ny] & bit) != 0) {\n                    redNeighbors++;\n                }\n            }\n        }\n    }\n\n    function wrapY(uint8 y, int8 dy, uint8 height) private pure returns (uint8) {\n        int16 nyI = int16(uint16(y)) + dy;\n        if (nyI < 0) return height - 1;\n        if (nyI >= int16(uint16(height))) return 0;\n        return uint8(uint16(int16(nyI)));\n    }\n}\n"
      }
    }
  }
}