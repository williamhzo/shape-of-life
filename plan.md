# Conway Arena (Shape L2) v0.1 Spec and Implementation Plan

This document defines a flexible v0.1 spec for a multiplayer, onchain Conway’s Game of Life experience on Shape L2, plus a detailed implementation plan aligned with the preferred stack: TypeScript, Next.js (App Router + route handlers), Tailwind, shadcn/ui, Hardhat, Foundry, wagmi, viem, Vitest, Turborepo, Bun, and Alchemy RPC.

## 0. Goals

Build a spectator-first, multiplayer arena where:
- Many players participate in the same round (social, shared world).
- Players sign only 2 transactions per round (commit + reveal), plus optional claim/mint.
- Simulation is deterministic and executed onchain in batches.
- Outcomes are neutral and verifiable (contract state is canonical).
- Gas costs remain low via packed bitboards, bounded board size, bounded participants.

Shape-native: optionally recycle Shape Gasback proceeds into prize pools and keeper incentives. Shape Gasback returns 80% of sequencer (L2) fees generated by interactions with registered contracts to contract owners once registered.  
Refs:
- https://docs.shape.network/building-on-shape/gasback

---

## 1. Glossary

- **Season**: A long-running configuration epoch (parameters, scoring weights, cosmetics, reward strategy).
- **Round**: One match with a fixed board, fixed phase windows, deterministic simulation.
- **Team**: Blue or Red (Immigration two-color model).
- **Seedlet**: A small pattern contributed by one player (bitmask).
- **Slot**: A predefined spawn location reserved during commit, used to place a seedlet at round start.
- **Keeper**: Any address calling `stepBatch` to advance simulation.

---

## 2. Core Automaton Rules

### 2.1 Cell state
Each cell is:
- Dead
- Alive (Blue)
- Alive (Red)

We maintain two disjoint bitboards: `blue` and `red`. A cell is alive if `(blue | red) == 1` for that cell. Invariant: `blue & red == 0`.

### 2.2 Neighborhood
Standard Moore neighborhood (8 adjacent cells).

### 2.3 Life rule (B3/S23)
- Dead cell is born with exactly 3 live neighbors.
- Live cell survives with 2 or 3 live neighbors.
- Otherwise it dies/stays dead.

Refs:
- https://conwaylife.com/wiki/Conway%27s_Game_of_Life
- https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life

### 2.4 Color rule (Immigration)
- Survivors keep their color.
- Newborn cell (always 3 neighbors under B3 births) takes the **majority color** of its three neighbors.

Refs:
- https://conwaylife.com/wiki/Colourised_life

### 2.5 Topology
Default v1 topology: **Cylinder**
- Wrap on Y (vertical): row -1 → row 63, row 64 → row 0.
- Hard edges on X (horizontal): out-of-bounds is dead.

Topology is configurable per season/round.

---

## 3. Board and Packing

### 3.1 Board size
Default: **64×64** (4096 cells).

Optional future variants:
- 96×64 or 128×64 (wider battlefield).
- 128×128 (heavier compute; requires tighter tick limits/batching).

### 3.2 Packed representation (storage)
For 64×64:
- Represent each row as 64 bits (`uint64`).
- Pack 4 rows into one `uint256` (4 × 64 = 256).
- 64 rows → 16 `uint256` words per team.

Per round storage:
- `uint256[16] bluePacked`
- `uint256[16] redPacked`

In-memory stepping uses:
- `uint64[64] blueRows`
- `uint64[64] redRows`

On `stepBatch`:
1. Unpack packed words → row arrays
2. Step N generations in memory
3. Repack and write back once

This reduces SSTORE writes.

---

## 4. Seedlets, Slots, and Participation

### 4.1 Seedlet size and cell budget
Default v1:
- Seedlet: **8×8** stored as `uint64`
- Budget: **K = 12** live cells (tunable)

This supports many participants per round while keeping overlap and compute bounded.

Optional “pro rounds”:
- Seedlet: 16×16 stored as `uint256` with budget K ≈ 32
- Fewer slots or larger board

### 4.2 Slot grid and team territories
For 64×64 with 8×8 seedlets:
- 8×8 slot grid → **64 slots**
- Team allocation by tile column:
  - Blue: tileX in [0..3] (x 0..31)
  - Red: tileX in [4..7] (x 32..63)
- Territory validation: `tileX = slotIndex % SLOT_COLUMNS`, Blue allowed if `tileX < 4`, Red allowed if `tileX >= 4`.

Result: 32 slots per team, no overlap by construction. Territory axis matches invasion scoring axis (x-based left/right).

### 4.3 Slot reservation rules
- Commit reserves exactly one slot.
- One commit per slot.
- At most one reserved slot per address (v1).

### 4.4 Client-side transforms
Allowed before committing:
- rotate 90/180/270
- mirror X/Y
- translate inside 8×8 seedlet

Onchain stores only the resulting bitmask.

### 4.5 Commit hash encoding
Commit preimage binds:
- `roundId`
- `chainId` (required)
- `arena` (contract address, required)
- `player`
- `team`
- `slotIndex`
- `seedBits`
- `salt`

Example:
`commitHash = keccak256(abi.encode(roundId, block.chainid, address(this), player, team, slotIndex, seedBits, salt))`

Including `player` and `arena` prevents copying another reveal and replaying across deployments.

---

## 5. Round Lifecycle

### 5.1 Phases
1. Commit
2. Reveal
3. Simulation
4. Claim

`finalize(roundId)` is a transition action from `Simulation -> Claim`, not a standalone phase in v0.1.

### 5.2 Timing defaults (configurable)
- Commit: 90s
- Reveal: 60s
- Simulation: until `maxGen` or early end
- `maxGen`: 256
- `maxBatch`: start with 16 or 32 and tune via benchmarking

### 5.3 Liveness
- Permissionless stepping with keeper rewards
- Official keeper bot to avoid stalls, but anyone may step and earn rewards

### 5.4 Transition guards (v0.1)
- `commit`: only in Commit, before `commitEnd`, valid team/slot, empty slot, and one reserved slot per address.
- `reveal`: only in Reveal, before `revealEnd`, caller must match committed player, preimage must match `commitHash`, budget must be `<= seedBudget`, one reveal only.
- `initialize`: callable once after `revealEnd`; builds initial board from revealed slots only; sets phase to Sim.
- `stepBatch`: only in Sim; advances `actualSteps = min(requestedSteps, maxBatch, maxGen - gen)`; keeper reward uses `actualSteps` only.
- `finalize`: only in Sim when `gen == maxGen` or one team is extinct; computes scores/winner and sets phase to Claim.
- `claim`: only in Claim; only revealed slot owner can claim; one claim per slot.

---

## 6. End Conditions and Scoring

### 6.1 End conditions
Round ends when:
- `gen == maxGen`, or
- one team is extinct (its entire bitboard is empty); early termination is enabled by default in v0.1

### 6.2 Recommended v1 scoring (cheap and watchable)
Avoid per-tick scoring onchain in v1. Compute score at finalize.

At final generation:
- `finalPopBlue = popcount(blue)`
- `finalPopRed  = popcount(red)`
- `invadeBlue   = popcount(blue ∩ rightHalf)` (x >= 32)
- `invadeRed    = popcount(red  ∩ leftHalf)`  (x < 32)

Score:
- `scoreBlue = 3*finalPopBlue + 2*invadeBlue`
- `scoreRed  = 3*finalPopRed  + 2*invadeRed`

Winner:
- If one team extinct: other team wins
- Else: higher score wins

### 6.3 Tiebreakers
v1 recommendation:
- Draw splits winner pool equally across all revealed participants (both teams), and both teams may mint the artifact

Optional deterministic coinflip:
- `keccak256(roundId, finalBoardHash)` parity

Optional VRF later:
- Shape Gelato VRF guide: https://docs.shape.network/tools/oracles/gelato-vrf

---

## 7. Economy and Shape-Native Features

### 7.1 Round types
1) Casual (free entry)
- No entry fee
- No reservation bond by default (`reservationBond = 0`)
- No payout (or sponsored)
- Rewards: leaderboards, badges, artifacts

2) Ranked (paid entry)
- Entry fee per commit
- Prize pool split among:
  - winning team participants (revealed slots only)
  - keepers (steppers)
  - protocol/treasury (optional)

### 7.2 Non-reveal penalty
Committed but not revealed:
- Slot remains empty
- In ranked: fee forfeited to pools (prize/keepers)
- If `reservationBond > 0`, bond is forfeited to pools on non-reveal

### 7.3 Keeper rewards
A `keeperPool` funded by:
- portion of entry fees and/or
- sponsorship and/or
- treasury recycling (including Gasback proceeds)

Reward per generation advanced:
- `rewardPerGen`
- Pay on `stepBatch` proportional to actual generations advanced

Cap total keeper rewards per round:
- `rewardPerGen * maxGen`
- On each `stepBatch`, `keeperReward = min(actualSteps * rewardPerGen, keeperPoolRemaining)` (never overpay)

### 7.4 Locked v0.1 payout model (low stakes)
For ranked rounds, use simple fixed shares:
- `winnerBps = 8000` (80%)
- `keeperBps = 2000` (20%)
- `treasuryBps = 0`
- Invariant: `winnerBps + keeperBps + treasuryBps == 10000`

Pool formulas:
- `totalEntry = entryFee * commitCount`
- `winnerPool = totalEntry * winnerBps / 10000`
- `keeperPool = totalEntry * keeperBps / 10000`
- `keeperPoolRemaining = keeperPool - keeperPaid`
- `winnerPoolFinal = winnerPool + keeperPoolRemaining` (unused keeper budget rolls to winners)

Claim formulas:
- If Blue or Red wins:
  - `revealedWinnerCount = # revealed slots on winning team`
  - `payoutPerWinner = winnerPoolFinal / revealedWinnerCount` (equal share)
- If Draw:
  - `revealedBothCount = # revealed slots across both teams`
  - `payoutPerParticipant = winnerPoolFinal / revealedBothCount` (equal share)
- If divisor is zero (`revealedWinnerCount == 0` or `revealedBothCount == 0`), no participant claims are enabled and `winnerPoolFinal` is sent to `treasury`.

Rounding:
- Integer division dust goes to `treasury` to avoid stuck balance.

Eligibility:
- Only revealed slots can claim.

### 7.5 Low-stakes anti-griefing defaults
- Casual starts fully free (`entryFee = 0`, `reservationBond = 0`) to keep friction minimal.
- Ranked uses entry fees as the primary anti-spam cost.
- Existing onchain controls remain mandatory: one commit per slot and one reserved slot per address.
- If spam becomes a problem, set `reservationBond > 0` in a later season without contract migration.

### 7.6 Gasback loop
Register arena contracts for Gasback and periodically claim into a treasury. Recycle into:
- sponsored rounds
- keeper pools
- seasonal prize pools

Refs:
- https://docs.shape.network/building-on-shape/gasback
- https://docs.shape.network/tutorials/registering-contract-gasback/programmatically

### 7.7 Stack medals and reputation
Plan to emit events or integrate later with Shape Stack:
- https://docs.shape.network/the-stack

---

## 8. Smart Contract Specification

### 8.1 Contract layout
- `ConwayArena`: round state machine, commits/reveals, stepping, finalization, payouts
- `ConwayEngine` (library): pack/unpack, stepping, popcount utilities
- Optional: `RoundArtifactNFT` (ERC-1155 or ERC-721)

### 8.2 Enums
- `Phase { Commit, Reveal, Sim, Claim }`
- `Team { Blue, Red }`
- `Topology { HardEdges, Torus, Cylinder }`

### 8.3 Round config (per round or per season)
- `width = 64`, `height = 64`
- `topology = Cylinder`
- `maxGen = 256`
- `earlyExtinction = true`
- `seedSize = 8` (8×8)
- `seedBudget = 12`
- `commitDuration = 90s`
- `revealDuration = 60s`
- `maxBatch = 16..32`
- `scoreWeightPop = 3`
- `scoreWeightInvade = 2`
- `entryFee` (0 for casual)
- `reservationBond` (default 0)
- `winnerBps = 8000`
- `keeperBps = 2000`
- `treasuryBps = 0`
- `rewardPerGen` (optional)
- `treasury` (receives dust and optional protocol share)

### 8.4 Storage structures (suggested)
- `mapping(uint256 => RoundCore) rounds`
- `mapping(uint256 => mapping(uint8 => Slot)) slots`

`RoundCore`:
- `Phase phase`
- `uint40 commitEnd`
- `uint40 revealEnd`
- `uint16 gen`
- `uint256[16] bluePacked`
- `uint256[16] redPacked`
- `bool initialized`
- `bool finalized`
- `uint32 scoreBlue`
- `uint32 scoreRed`
- `uint8 winner` (0 Blue, 1 Red, 2 Draw)
- `uint256 winnerPool`
- `uint256 keeperPoolRemaining`
- `uint256 keeperPaid`

`Slot`:
- `address player`
- `uint8 team`
- `bytes32 commitHash`
- `uint64 seedBits`
- `bool revealed`
- `bool claimed`

### 8.5 Public functions

Round management:
- `createRound(Config cfg)` (admin v1)
- `getRoundState(roundId)` view

Commit:
- `commit(roundId, team, slotIndex, commitHash)` payable

Reveal:
- `reveal(roundId, team, slotIndex, seedBits, salt)`

Initialize:
- `initialize(roundId)` (anyone after reveal ends or called implicitly in step)

Stepping:
- `stepBatch(roundId, steps)` (permissionless, pays keeper reward)

Finalize:
- `finalize(roundId)` (permissionless once end condition met)

Claim:
- `claim(roundId, slotIndex)`
- `previewClaim(roundId, slotIndex)` view

Artifacts (optional):
- `mintArtifact(roundId)` (participants or winners)

### 8.6 Events
- `RoundCreated(roundId, cfg)`
- `Committed(roundId, player, team, slotIndex)`
- `Revealed(roundId, player, team, slotIndex, seedHash)`
- `Initialized(roundId)`
- `Stepped(roundId, fromGen, toGen, keeper, reward)`
- `Finalized(roundId, winner, scoreBlue, scoreRed, finalBoardHash, winnerPoolFinal, keeperPaid)`
- `Claimed(roundId, player, slotIndex, amount)`
- `ArtifactMinted(roundId, player, tokenId)`

### 8.7 Access control and safety
- Owner/admin controls for round creation, config, pausing, treasury
- `nonReentrant` on claim
- Pull payments
- Cap keeper payouts
- Validate config invariants (`winnerBps + keeperBps + treasuryBps == 10000`)
- Validate invariants (`blue & red == 0`)

---

## 9. Offchain System Specification

### 9.1 Frontend (Next.js App Router + Tailwind + shadcn/ui)
Pages:
1) Spectator Home
- live board, phase timer, gen counter, populations, join CTA

2) Join Flow
- team select / auto-balance
- slot picker
- 8×8 seed editor + presets + transforms + budget meter
- commit tx + reveal tx

3) Round Live View
- local animation between onchain checkpoints
- keeper feed + participant list (from indexer)

4) End Screen
- winner summary, claim, artifact mint, replay share

Rendering:
- `<canvas>` with `ImageData` for efficient 64×64 scaling.

Wallet:
- wagmi + viem

API surface:
- Next.js App Router route handlers (`app/api/**/route.ts`) for server-side endpoints (health, replay metadata, indexer-backed reads).

### 9.2 Indexing
Start with a TS-first indexer for speed:
- Ponder (recommended for iteration)
Then optionally move to hosted:
- Goldsky / Alchemy Subgraphs

Shape data indexer refs:
- https://docs.shape.network/tools/data-indexers

### 9.3 Simulation worker and artifacts
A Node worker replays rounds from revealed seeds + config to generate:
- replay JSON
- thumbnail(s)
- mp4/gif share asset

Store on IPFS/Arweave or CDN and reference via metadata hash.

### 9.4 Keeper bot
Bot watches rounds in Sim phase and calls `stepBatch` with safe `stepsPerCall`.
Even with bot, keep stepping permissionless.

### 9.5 RPC provider
- Use Alchemy as the default RPC provider for Shape Sepolia and Shape Mainnet.
- Configure `SHAPE_SEPOLIA_RPC_URL` and `SHAPE_MAINNET_RPC_URL` with Alchemy endpoints (API key provided by operator).

---

## 10. Implementation Plan (Preferred Stack)

This project uses:
- TypeScript + Next.js (`apps/web`) for UI and wallet flows.
- Foundry + Hardhat (`packages/contracts`) for Solidity tests, gas checks, deployment, verification, and Sepolia operations.
- TypeScript simulation engine (`packages/sim`) as deterministic parity reference.

Historical phase-by-phase rollout items were removed as legacy/completed.
Active implementation and release work is tracked in section 15.

---

## 11. Repo Structure (recommended)

Monorepo (Turborepo + Bun workspaces):
- Root:
  - `turbo.json`
  - `package.json` (Bun workspaces)
  - `bunfig.toml`
- `apps/web` (Next.js App Router + `app/api/**/route.ts`)
- `packages/contracts` (Foundry + Hardhat)
  - `src/`, `test/`, `foundry.toml`
  - `hardhat.config.ts`, `ignition/`, `scripts/`
- `packages/sim` (TS engine + fixtures)

Key principle: use the TS engine to generate Solidity test fixtures.
Refs:
- https://turborepo.dev/docs
- https://bun.com/docs

---

## 12. Hardhat vs Foundry Guidance

Use both, with boundaries:
- Foundry: unit tests, fuzzing, invariants, gas snapshots
- Hardhat: deployments (Ignition), viem-based scripts, verification
- Vitest: TypeScript unit/integration tests for `packages/sim` and `apps/web` lib modules

---

## 13. Correctness and Failure Modes Checklist

1) Engine neighbor counting bugs
- Mitigate with golden vectors + fuzz comparisons vs TS engine.

2) Packing/unpacking misalignment
- Mitigate with invertibility tests and explicit pack layout tests.

3) Topology mismatch (cylinder wrap)
- Enforce identical behavior in TS and Solidity.

4) Keeper reward abuse
- Pay only for generations advanced; cap total rewards per round.

5) Round liveness
- Permissionless stepping + official keeper bot.

6) Claim safety
- Pull payments + `nonReentrant` + careful accounting.

---

## 14. v1 Defaults Summary

- Board: 64×64
- Topology: cylinder (wrap Y, hard X)
- Teams: Blue vs Red (Immigration)
- Seedlet: 8×8 (`uint64`)
- Budget: 12 cells
- Slots: 64 total (32 per team)
- Commit: 90s
- Reveal: 60s
- MaxGen: 256
- Early extinction: enabled
- MaxBatch: 16 or 32 (benchmark on Shape Sepolia)
- RPC provider: Alchemy (`SHAPE_SEPOLIA_RPC_URL`, `SHAPE_MAINNET_RPC_URL`)
- Testing: Vitest (TS) + Foundry (Solidity)
- Web API: Next.js App Router route handlers (`app/api/**/route.ts`)
- Score: `3*finalPop + 2*invasionPop`
- Modes: Casual (free), Ranked (fee + payouts + keeper rewards)
- Ranked split: winners 80%, keepers 20%, treasury 0% (plus dust)
- Winner payouts: equal share across revealed winning slots (or all revealed slots on draw)
- Casual anti-spam default: `reservationBond = 0` (can be enabled later)

---

## 15. Final-Stage Sepolia Hardening Plan (2026-02-25)

This section supersedes earlier "near-complete" framing from prior revisions and defines current release-readiness work.
Goal: complete final-stage hardening through autonomous Shape Sepolia validation, contract security gates, and wallet UX flow reliability checks.

### 15.1 Locked Execution Decisions

- Round targeting: deploy a fresh Sepolia round per scenario run, plus smoke-check current deployed round.
- Wallet strategy: generate ephemeral test wallets and require operator funding before run start.
- Security gate depth: full hardening gate (fuzz/invariants + adversarial Sepolia scenarios + static analysis when available).
- UX validation mode: add test-wallet mode to enable autonomous browser commit/reveal/claim and rejection-path testing.
- Run intensity: balanced matrix (20-30 autonomous rounds) with varied seeds/slots/timing/adversarial cases.
- Funding gate: enforce balance preflight checks before any scenario execution.

### 15.2 Impact-Ordered Priorities

- P0:
  - Security/correctness blockers and adversarial lifecycle coverage.
  - Autonomous Sepolia scenario orchestration and deterministic failure reporting.
  - Preflight enforcement (keys, chain, wallet funding, toolchain, compile prerequisites).
- P1:
  - Browser-level wallet UX automation and action sequencing validation.
  - Event/state read-model robustness under longer high-event runs.
- P2:
  - Release gate consolidation and command/doc consistency.
  - Operator report artifacts and runbook clarity.
- P3:
  - Additional UX polish and long-run monitoring enhancements.

### 15.3 Execution Phases

#### Phase 1: P0 Baseline and Gate Drift Fix

[ ] Add a single preflight script for Sepolia hardening runs:
- Verify `SHAPE_SEPOLIA_RPC_URL`, required keys, chain id `11011`, cast availability, and minimum wallet balances.
- Verify compile/gas prerequisites, including explicit failure messaging for missing `solc 0.8.28` when gas checks are requested.

[ ] Remove command drift between checklist/docs and executable scripts:
- Align root/web lint gate naming (`lint:web` vs `lint`).
- Align gas gate naming (`test:gas` vs `test:contracts:gas`) across `README.md`, `ETHSKILLS_CHECKLIST.md`, and package scripts.

Exit criteria:
- Preflight provides deterministic pass/fail reasons.
- Documented gate commands exactly match executable commands.

#### Phase 2: P0 Autonomous Sepolia Scenario Harness

[ ] Add wallet generation utility and local wallet manifest output (gitignored).
[ ] Add wallet funding check utility with explicit per-role thresholds.
[ ] Add scenario orchestrator for deploy -> commit -> reveal -> initialize -> step -> finalize -> claim:
- Multi-wallet participant competition and keeper actions.
- Fresh round deployment by default; optional fixed round override.
- Transaction/result artifact capture (hashes, statuses, gas, revert reason, phase transitions).

[ ] Implement balanced scenario matrix (20-30 rounds):
- Happy path with claims.
- Non-reveal forfeits.
- Slot contention and timing races.
- Invalid reveal inputs (wrong team/slot/salt/player).
- Terminal finalize behavior (maxGen/extinction/draw).

Exit criteria:
- One command executes full autonomous Sepolia matrix and writes report artifacts.

#### Phase 3: P0 Contract Security Hardening Gate

[ ] Expand Foundry adversarial coverage:
- Stateful sequencing for lifecycle transitions and claim ordering.
- Accounting conservation under mixed claim/keeper withdrawal ordering.
- Reentrancy and payout-path abuse attempts.
- Step clamping and no over-advance guarantees.
- Commit hash domain separation bypass attempts.

[ ] Add static analysis stage (tool-available path, fail-closed on unresolved High/Critical findings).

Exit criteria:
- No unresolved High/Critical findings.
- Fuzz/invariant and adversarial suites green.

#### Phase 4: P1 Browser UX Automation

[ ] Add test-wallet mode for deterministic browser automation.
[ ] Add Playwright suite for core wallet flows:
- Connect.
- Wrong-network switch.
- Commit/reveal/claim success path.
- Rejection path and revert error surfacing.
- Loading/disabled state guards against duplicate submissions.

[ ] Resolve UX issues found by browser runs (action ordering, message clarity, phase-aware affordances).

Exit criteria:
- Browser suite validates end-to-end wallet flow reliability on Sepolia-backed flows.

#### Phase 5: P1 Read-Model and Runtime Robustness

[ ] Hardening follow-ups for live reads/events:
- Validate event query strategy under long-lived rounds and higher log counts.
- Add regression tests for participant/keeper feed reconstruction under higher event volume.

Exit criteria:
- Round live panels remain consistent and responsive through stress scenarios.

#### Phase 6: P2 Unified Release Gate and Artifacts

[ ] Add one canonical release gate command combining:
- Tests + fuzz/invariants.
- Gas checks.
- Web lint/build and browser validation.
- Sepolia scenario matrix + smoke + keeper observability.

[ ] Emit release artifact bundle:
- Scenario report.
- Security findings report.
- Gas benchmark/lock evidence.
- Deployment/verification metadata.

Exit criteria:
- Single-command go/no-go with auditable artifacts.

#### Phase 7: P2 Documentation and Plan Synchronization

[ ] Update `README.md` with canonical hardening commands.
[ ] Update `ETHSKILLS_CHECKLIST.md` gates and package expectations to match repo reality.
[ ] Keep this section and open checkboxes updated in each related PR.

Exit criteria:
- No stale command/doc references.
- Plan status reflects current implementation truth.

#### Phase 8: P3 Final Polish and Residual Risk Register

[ ] Triage remaining non-blocking UX bugs from automation/manual pass.
[ ] Record deferred risks with trigger conditions and mitigation owner.

Exit criteria:
- Candidate release status: no known critical blockers, monitored residual risk only.

### 15.4 Canonical Validation Gates for Final Stage

- Core test gate: `bun run test`
- Gas gate: `bun run test:gas`
- Lint gate: `bun run lint`
- Web build gate: `cd apps/web && bun run build`
- Sepolia smoke gate: `SHAPE_SEPOLIA_RPC_URL=... ROUND_ADDRESS=... bun run smoke:sepolia:round`
- Keeper observability: `SHAPE_SEPOLIA_RPC_URL=... ROUND_ADDRESS=... bun run observe:sepolia:keeper`
- Max-batch benchmark/lock: `SHAPE_SEPOLIA_RPC_URL=... ROUND_ADDRESS=... bun run benchmark:sepolia:max-batch:lock`

### 15.5 Risks and Failure Modes to Watch

- Sepolia orchestration flakiness (RPC latency/limits): mitigate with retries + deterministic run artifacts.
- Security false confidence from happy-path bias: mitigate with adversarial sequencing and invariants.
- Wallet UX drift between mocked/unit and real signing behavior: mitigate with browser automation + live wallet checks.
- Gate/doc drift recurrence: mitigate with one canonical release command and synchronized checklist updates.
